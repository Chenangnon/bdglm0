
#' @name bdfamilies
#' @aliases bdgamma bdggamma
#' @title Balanced Discrete Families and Links
#' @description Family and link functions for the balanced discrete family models.
#' @usage bdgamma (link = "log")
#' bdggamma (link = "log")
#' shape.link (link = "log", family = "bdgamma")
#' shp.links (link.scale = "log", link.shape = NULL, link.shape2 = NULL)
#'
#' @param link a specification for the model link function. This can be a name/expression, a literal character string, a length-one character vector or an object of class "link-glm" (such as generated by make.link) provided it is not specified via one of the standard names given next.
#' @param family a description of the distribution of the (mean) model. It can be a character string naming a family function, a family function, an object with a family attribute or the result of a call to a family function.
#' @param link.scale,link.shape,link.shape2 characters naming link functions for scale and shape models respectively. The default (NULL) corresponds to the defaults for the \code{shape.link} function, i.e. 'log' link.
#'
#' Most built-in balanced discrete families accepts the links \code{log} and \code{sqrt}. The \code{Bbinomial} (beta binomial) family accepts the links logit, probit, cauchit, (corresponding to logistic, normal and Cauchy CDFs respectively), and cloglog (complementary log-log).
#'
#' Either of these same links can be used for scale and shape models. Using however any of logit, probit, cauchit or cloglog links means that the corresponding distribution parameter is constrained to (0,1) what may not make any specific sens.

bdgamma <- function (link = "log") {
  linktemp <- substitute(link)
  if (!is.character(linktemp))
    linktemp <- deparse(linktemp)
  okLinks <- c("log", "sqrt", "identity", "inverse")
  if (linktemp %in% okLinks)
    stats <- make.link(linktemp)
  else if (is.character(link)) {
    stats <- make.link(link)
    linktemp <- link
  }
  else {
    if (inherits(link, "link-glm")) {
      stats <- link
      if (!is.null(stats$name))
        linktemp <- stats$name
    }
    else {
      stop(gettextf("link \"%s\" not available for balanced discrete gamma family; available links are %s",
                    linktemp, paste(sQuote(okLinks), collapse = ", ")),
           domain = NA)
    }
  }
  variance <- function(mu, scale, ...)
    bdvariance(mu = mu, scale = scale, family = "bdgamma")
  validmu <- function(mu)
    all(is.finite(mu)) && all(mu > 0)
  make.mlcriterion <- expression({
    if (p > 0 & q > 0)
      mlcriterion <- function (theta) {
        beta <- theta[1:p]
        delta <- theta[-(1:p)]
        -sum(wt * ddgamma(y, mu = linkinv(drop(offset + x %*% beta)),
                          a = linkinv(drop(zoffset + z %*% delta)),
                          log = TRUE))
      }
    else if (p > 0)
      mlcriterion <- function (beta) {
        -sum(wt * ddgamma(y, mu = linkinv(drop(offset + x %*% beta)),
                          a = link.scale$linkinv(zoffset),
                          log = TRUE))
      }
    else if (q > 0) {
        mlcriterion <- function (delta) {
          -sum(wt * ddgamma(y, mu = linkinv(offset),
                            a = link.scale$linkinv(drop(zoffset + z %*% delta),
                            log = TRUE)))
        }
    }
    mlcriterion
  })
  # Derivatives of the log-likelihood function 'mlcriterion' with respect to theta



  dev.resids <- function(y, mu, scale, wt, logLsat, ...) {
    wt * 2 * (logLsat - .bdgammalogL (y, mu, scale))
  }
  aic <- function(y, mu, scale, wt = 1, npars, ...) {
    -2 * sum(wt * .bdgammalogL (y, mu, scale)) + 2 * npars
  }
  initialize <- expression({
    if (any(y < 0))
      stop("negative values not allowed for the 'balanced discrete gamma' family")
    Beta <- glm.fit(x = x, y = y, weights = weights, offset = offset,
                    family = poisson(), control = list(maxit = 25), singular.ok = TRUE)
    start <- c(Beta$coefficients)
    NA.start <- is.na(start)
    start[NA.start] <- numeric(sum(NA.start))
    etastart <- Beta$linear.predictors
    mustart <- Beta$fitted.values
    if(nvars.scale == 0) {
      start.scale <- start.shape <- start.shape2 <- NULL
    }
    else {
      Beta <- lm.fit(x = x.scale, y = link.scale$linkfun (scale.sati),
                     singular.ok = TRUE)
      start.scale <- c(Beta$coefficients)
      NA.start <- is.na(start.scale)
      start.scale[NA.start] <- numeric(sum(NA.start))
      tryLL <- sum(bdgammalogL(y, mu = mustart,
                               scale = link.scale$linkinv(drop(x.scale %*% start.scale))))
      if (any(c(is.infinite(tryLL), is.na(tryLL))))
        start.scale <- rep(link.scale$linkfun(1), nvars.scale)
      start.shape <- start.shape2 <- NULL
      names(start.scale) <- xnames.scale
    }
  })
  simfun <- function(object, nsim) {
    param <- object$param
    rdgamma(object$nobs * nsim, mu = param$mu, a = param$scale)
  }
  structure(list(family = "bdgamma", link = linktemp, linkfun = stats$linkfun,
                 linkinv = stats$linkinv, bdglmlogL0 = bdgammalogL0,
                 bdglmlogL = bdgammalogL, variance = variance,
                 dev.resids = dev.resids, aic = aic,
                 mu.eta = stats$mu.eta, initialize = initialize,
                 validmu = validmu, valideta = stats$valideta,
                 simulate = simfun,  shape = FALSE, shape2 = FALSE),
            class = "bdfamily")
}

.bdgammalogL0 <-
  function (y, scale = NULL, whole = FALSE, tol = 1e-6, ...) {
  mu <- y
  mu[y == 0] <- tol
  if (is.null(scale))
    scale <- equia.bdgamma(mu = mu, tol = tol) / mu
  d <- ddgamma(y, mu = y, b = scale, log = TRUE)
  d[is.na(d)] <- 0
  if (whole)
    sum(d)
  else
    d
}

.bdgammalogL <-
  function (y, mu, scale = 1, whole = FALSE) {
  d <- ddgamma(y, mu = mu, b = scale, log = TRUE)
  if (whole)
    sum(d)
  else
    d
}

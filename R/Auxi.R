#' @name direct_operators
#' @title Special matrix product operators
#' @aliases dirprod kronprod dirsum kronsum
#' @description Kronecker product (direct product), Kronecker sum, Direct sum (bloc diag). The code for dirrect product is from library "dae". We only add recursive call to offer the possibility to directly  compute \code{A @ B @ C @ ...}, (\code{@} denoting the direct product).
#' @param A,B,C,... matrices
#' @return matrix whose dimension depends on the operation and the sizes of the entry matrices.
#'
#' @usage dirprod (A, B, C, ...)
#'
#' dirsum (A, B, C, ...)
#'
#' kronsum (A, B)
#'

dirprod <- function (A, B, C, ...) {
  A <- as.matrix(A)
  B <- as.matrix(B)
  if (!missing(C))
    return( dirprod(dirprod(A, B), C, ...) )
  rA <- nrow(A)
  cA <- ncol(A)
  rB <- nrow(B)
  cB <- ncol(B)
  Aexp <- A[rep(1:rA, each = rB), rep(1:cA, each = cB)]
  Bexp <- eval(parse(text = paste("cbind(", paste(rep("B",
                                                      cA), collapse = ","), ")")))
  Bexp <- eval(parse(text = paste("rbind(", paste(rep("Bexp",
                                                      rA), collapse = ","), ")")))
  Aexp * Bexp
}

# An allias for dirprod
kronprod <- dirprod

#
kronsum <- function (A, B) {
  if (is.vector(A) && is.vector(B)) {
    rA <- length(A)
    rB <- length(B)
    if (rA != rB)
      stop("Vector lengths differ")
  } else {
    A <- as.matrix(A)
    B <- as.matrix(B)
    rA <- NROW(A)
    cA <- NCOL(A)
    rB <- NROW(B)
    cB <- NCOL(B)
    if (any( all(cA == 1, cB == 1, rA == rB),
             all(rA == 1, rB == 1, cA == cB),
             all(rA == 1, cB == 1, cA == rB),
             all(cA == 1, rB == 1, rA == cB) ))
      return(kronsum(as.vector(A), as.vector(B)))
    if (rA != cA)
      stop("Matrix A must be square")
    if (rB != cB)
      stop("Matrix B must be square")
  }
  dirprod(B, diag(rA)) + dirprod(diag(rB), A)
}

# code from $matrixcalc::direct.sum$
dirsum <- function (A, B, C, ...) {
  A <- as.matrix(A)
  B <- as.matrix(B)
  if (!missing(C))
    return( dirsum(dirsum(A, B), C, ...) )
  rA <- nrow(A)
  cA <- ncol(A)
  rB <- nrow(B)
  cB <- ncol(B)
  rbind(cbind(A, matrix(0, rA, cB)),
        cbind(matrix(0, rB, cA), B))
}

#' @name vec
#' @aliases vech as.line
#' @title vec and related operators
#' @description Vectorization or vechorization of a matrix, inverse vechorization of a vector, coercion of a vector/matrix into a line.
#'
#' @details \code{vec} behaves like \link{as.vector}, but returns a one column matrix.
#'
#' \code{vech} stacks the lower triangle (diagonal and sub diagonal) elements of its matrix argument and returns a one column matrix.
#'
#' The \code{as.line} function is different from the 'vec' function in two ways: (1) \code{vec} works along columns, i.e. it takes the first column, then the second and so on, \code{as.line} works on contrary along rows, as such, \code{as.line(A) = vec(t(A))}; (2) vec returns a vector object whereas as.line returns a one row matrix object.
#'
#' \code{vechouter} takes a vector (considered as a row) or a matrix, subsequently applies the \link{outer} (with FUN = '*') and the vech operators to each row. So for a n-by-p matrix input, the output is n-by-p(p+1)/2.
#'
#' @param x,v an R object: matrix or vector
#' @usage
#'     vec(x)
#'     vech(x)
#'     as.line(v)
#'
#' @return The functions return numeric vectors (one column matrix) or a line vector.
#'
# vec function
vec <- function (x) {
  x <- as.matrix(x)
  if (!is.numeric(x))
    stop("argument x is not numeric")
  t(t(as.vector(x)))
}

# Symmetry and square are not checked
vech <- function(x) {
  if (!is.matrix(x)) {
    if (length(x) == 1)
      return(x)
    else
      stop("'x' must be a matrix")
  }
  x[lower.tri(x, diag = TRUE)]
}

# Coerce a vector/matrix to be a line
as.line <- function (v)
  matrix(as.vector(t(v)), nrow = 1)


#' @name tryCatchWE
#' @title Condition Handling and Recovery
#' @description A \code{try catch}-like function which provides a mechanism for handling unusual conditions, including errors and warnings..
#' It particularly allows to recover error and warning messages and to disply them at will.
#'
#' @param expr expression to be evaluated
#'
#' @usage
#' tryCatchWE (expr)
#'
#' @return a list with elements:
#'
#' \item{value}{ the result of the evaluation, a regular object or an error message}
#' \item{warning}{ warning message generated by the evaluation, \code{NULL} if none.}
#'
#' @source
#' The R Core Team (Copyright (C) 2010-2012)
#'
#' @seealso
#' \link{stop}, \link{warning}, \link{try} and \link{tryCatch}.
#'
tryCatchWE <-
  function (expr) {
  W <- NULL
  w.handler <-
    function(w) {
      W <<- w
      invokeRestart("muffleWarning")
    }
  list(value = withCallingHandlers(tryCatch(expr,
                                            error = function(e) e), warning = w.handler),
       warning = W)
}

